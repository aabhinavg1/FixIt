name: Build and Notify

on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]

jobs:
  build_and_notify:
    runs-on: ubuntu-latest

    steps:
      # ---------------------------------
      # 0) Checkout
      # ---------------------------------
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 10

      # ---------------------------------
      # 1) Detect docs changes (file truth)
      # ---------------------------------
      - name: Detect docs changes
        id: detect_docs
        run: |
          DOCS_CHANGED="$(git diff --name-only HEAD^ HEAD | grep '^docs/' || true)"

          if [ -n "$DOCS_CHANGED" ]; then
            echo "docs_changed=true" >> $GITHUB_OUTPUT
          else
            echo "docs_changed=false" >> $GITHUB_OUTPUT
          fi

          echo "DEBUG docs_changed_files:"
          echo "$DOCS_CHANGED"

      # ---------------------------------
      # 2) Read commit messages (LATEST link wins)
      # ---------------------------------
      - name: Read commit messages
        run: |
          if [ "${{ steps.detect_docs.outputs.docs_changed }}" = "true" ]; then
            echo "Docs changed. Scanning recent commits for latest link:"
            LOG="$(git log --pretty=format:'---%n%B' HEAD~10..HEAD)"
          else
            echo "No docs changed. Reading HEAD commit message only"
            LOG="$(git log -1 --pretty=format:'---%n%B')"
          fi

          echo ""
          echo "================= RAW COMMIT LOG READ BY CI ================="
          echo "$LOG"
          echo "============================================================="
          echo ""

          # Latest link wins (nearest to HEAD)
          LINK="$(echo "$LOG" | awk '
            /^---$/ { next }
            /^[[:space:]]*[Ll][Ii][Nn][Kk]:/ {
              sub(/^[[:space:]]*[Ll][Ii][Nn][Kk]:[[:space:]]*/, "", $0)
              print $0
              exit
            }')"

          # nodoc can exist anywhere
          NODOC="$(echo "$LOG" | grep -i '^[[:space:]]*nodoc' || true)"

          echo "LINK=$LINK" >> $GITHUB_ENV
          echo "NODOC=$NODOC" >> $GITHUB_ENV

          echo "DEBUG FINAL LINK  = [$LINK]"
          echo "DEBUG FINAL NODOC = [$NODOC]"

      # ---------------------------------
      # 3) Enforce commit message policy
      # ---------------------------------
      - name: Enforce commit message policy
        run: |
          if [ "${{ steps.detect_docs.outputs.docs_changed }}" = "true" ]; then
            if [ -z "$LINK" ]; then
              echo "Docs changed but missing 'link:' in the latest commit"
              exit 1
            fi
          else
            if [ -z "$NODOC" ]; then
              echo "No docs changed but missing 'nodoc' in commit message"
              exit 1
            fi
          fi

      # ---------------------------------
      # 4) Validate route format
      # ---------------------------------
      - name: Validate link format
        if: env.LINK != ''
        run: |
          if ! echo "$LINK" | grep -q '^/'; then
            echo "Invalid link format. link must start with '/'"
            exit 1
          fi
          echo "Validated route: $LINK"

      # ---------------------------------
      # 5) Build site
      # ---------------------------------
      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      - name: Build site
        run: npm run build

      # ---------------------------------
      # 6) Discord notification
      # ---------------------------------
      - name: Send Discord notification
        if: success() && env.LINK != ''
        env:
          GENERAL_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_GENERAL }}
          LLVM_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_LLVM_DISCUSSION }}
        run: |
          ARTICLE_URL="https://www.compilersutra.com/docs${LINK}"
          MSG="New article published on CompilerSutra\n${ARTICLE_URL}"

          clean() {
            echo "$1" | tr -d '\r\n' | xargs
          }

          send() {
            WEBHOOK="$(clean "$1")"
            [ -z "$WEBHOOK" ] && return
            curl -sS \
              -H "Content-Type: application/json" \
              -X POST \
              --data-binary "$(printf '{"content":"%s"}' "$MSG")" \
              "$WEBHOOK"
          }

          if echo "$LINK" | grep -q '^/llvm'; then
            send "$LLVM_WEBHOOK"
          else
            send "$GENERAL_WEBHOOK"
          fi
